"""
Run TIPMOC 'trials' times, save data, and generate figures.

Set trials=100 and dynamics={1,2,3,4,5,6,7,8,9} to generate results for Table 1.
diagnostic_analysis.py further processes the results produced by this code, to ptoduce the numbers shown in Table 1.

The results generated by this code with trials=100 and dynamics=1 are also used by diagnostic_analysis.py to produce Figure 3.

Set trials=1 and dynamics=1 (i.e., double-well dynamical system) to generate reesults for Figures 2(a) and 2(b).

Place LFR.csv (the network with 100 nodes) to run the mutualistic-interaction dynamics (i.e., dynamics=7).

No other input files are required, but delta_aicc.py, run_X.py (X = various dynamics) and fit_powerlaw.py must be in the same folder. See the 'import' lines below.
    
Output:
    all_runs_result.csv --> I renamed this by adding the dynamical system's name.
    last_trial_raw_data.csv, which stores raw data from the last simulation run. It is used for Figures 2(a) and 2(b). I renamed it to last_trial_raw_data_dw.csv

    panel_a.pdf --> Figure 2(a), but the final Figure 2(a) is produced by one_run_plot_using_given_data.py, which reads last_trial_raw_data_dw.csv and fine-tune the appearance of the figure.

    panel_b.pdf --> Figure 2(b), but the final Figure 2(b) is similarly produced by one_run_plot_using_given_data.py

"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
import delta_aicc as dAICc
import run_double_well as dw
import run_over_harvesting as oh
import run_mutualistic as mu
import run_ou as ou
from scipy.stats import kendalltau
import matplotlib.ticker as ticker # adjust ytics number labels

import os
import csv

np.set_printoptions(precision=4, suppress=True)
random.seed()

dynamics = 1
trials = 100
i0 = 8  # We skip the first i0-1 values of control parameter before starting model comparison

tau_all_trials = []
detected_all_trials = []
u_det_all_trials = []
hatuc_det_all_trials = []
gamma_at_detection_all_trials = []
best_corr_at_detection_all_trials = []

threshold_AICc = -10

for tr in range(trials):
    # Generate data
    if dynamics==1: # double-well
        u_values, var_values = dw.run_double_well(sigma=0.05)
    elif dynamics==2: # double-well with randomly spaced control parameter values, $u$
        u_values, var_values = dw.run_double_well(sigma=0.05, poisson_u = True)
    elif dynamics==3: # double-well with randomly spaced $u$ and colored dynamical noise
        u_values, var_values = dw.run_double_well(sigma=0.05, poisson_u = True, colored_noise = True)
    elif dynamics==4: # over-harvesting, showing saddle-node bifurcation
        u_values, var_values = oh.run_over_harvesting(K=10, sigma=0.05)
    elif dynamics==5: # linear harvesting
        u_values, var_values = oh.run_linear_grazing(sigma=0.05)
    elif dynamics==6: # Rosenzweig-MacArthur
        u_values, var_values = oh.run_Kefi_model3(sigma=0.01) # 0.01
    elif dynamics==7: # mutualistic-interaction
        u_values, var_values = mu.run_mutualistic(sigma=0.15)
    elif dynamis==8: # OU process
        u_values, var_values = ou.run_ou(sigma=0.1)
    elif dynamics==9: # over-hareseting, without tipping
        u_values, var_values = oh.run_over_harvesting(K=2, sigma=0.05)

#    print(u_values)

    tau, _ = kendalltau(u_values, var_values)
    tau_all_trials.append(float(tau))

    delta_AICc_values = []
    a_values = []
    b_values = []
    hatuc_values = []
    gamma_values = []
    best_corr_values = []
    popt_lin_values = []
    num_u = len(u_values)

    print("Windowed AIC scan:")
    print("c     delta_AICc   hatuc  gamma   best_corr   index")
    for i in range(i0, num_u+1): # from i0 to num_u
        window_u = u_values[:i] # u_values[0] ... u_values[i-1]. So, i values in total
        window_var = var_values[:i]
        delta_AICc, popt_lin, a, b, hatuc, gamma, best_corr = dAICc.delta_AICc(window_u, window_var)
        print(f"{u_values[i-1]:.4g}  {delta_AICc:10.3f}  {hatuc:12.4f}  {gamma:12.4f}  {best_corr:12.4f}  {i}")
        delta_AICc_values.append(delta_AICc)
        a_values.append(a)
        b_values.append(b)
        hatuc_values.append(hatuc)
        gamma_values.append(gamma)
        best_corr_values.append(best_corr)
        popt_lin_values.append(popt_lin)

    delta_AICc_values = np.array(delta_AICc_values)
    a_values = np.array(a_values, dtype=float)
    b_values = np.array(b_values, dtype=float)
    hatuc_values = np.array(hatuc_values, dtype=float)
    gamma_values = np.array(gamma_values, dtype=float)
    best_corr_values = np.array(best_corr_values, dtype=float)
    popt_lin_values = np.array(popt_lin_values, dtype=float)

    print(f"tau = {tau:.4g}")

    # --- Detection logic: three consecutive threshold crossings ---
    detected = False

    # Check for three consecutive crossings
    for j in range(len(delta_AICc_values) - 2):
        # Only consider valid (not nan) values for three consecutive points
        if np.all(~np.isnan(delta_AICc_values[j:j+3])):
            if np.all(delta_AICc_values[j:j+3] <= threshold_AICc):
                detected = True
                detected_idx = i0 + j + 2  # last index in crossing window
                u_det = u_values[detected_idx-1]
                hatuc_det = hatuc_values[j+2]
                gamma_at_detection = gamma_values[j+2]
                best_corr_at_detection = best_corr_values[j+2]
                print(f"Detection: ΔAIC_c <= {threshold_AICc} for 3 points at u={u_det:.4g} (index {detected_idx})")
                print(f"Estimated critical point hatuc = {hatuc_det:.4g}, gamma = {gamma_at_detection:.4g}")
                break

    if not detected:
        print(f"No impending critical point detected (ΔAIC_C never ≤ {threshold_AICc} for three consecutive points)")
        detected_idx = None

    # append per-trial summary (use np.nan when not detected so columns are numeric)
    detected_all_trials.append(bool(detected))
    u_det_all_trials.append(u_det if detected else np.nan)
    hatuc_det_all_trials.append(hatuc_det if detected else np.nan)
    gamma_at_detection_all_trials.append(gamma_at_detection if detected else np.nan)
    best_corr_at_detection_all_trials.append(best_corr_at_detection if detected else np.nan)

    print("")  # Separate output for each trial

def fmt_val(x):
    """
    Format values for CSV:
    - None -> 'None'
    - numpy.nan or float('nan') -> 'NaN'
    - bool -> 'True'/'False'
    - numbers -> 4 decimals
    - other -> str(x)
    """
    if x is None:
        return 'None'
    if isinstance(x, bool):
        return str(x)
    try:
        # np.isnan handles numpy.nan and floats; it raises for non-numeric objects
        if np.isnan(x):
            return 'NaN'
    except Exception:
        pass
    try:
        return f"{float(x):.4f}"
    except Exception:
        return str(x)

output_file = 'all_runs_result.csv'

with open(output_file, 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['trial', 'tau', 'detected', 'u_det',
                     'hatuc_det', 'gamma_at_detection', 'best_corr_at_detection'])

    n_rows = len(tau_all_trials)
    for i in range(n_rows):
        detected_flag = detected_all_trials[i] if i < len(detected_all_trials) else False
        row = [
            i + 1,
            fmt_val(tau_all_trials[i]),
            fmt_val(detected_flag),
            fmt_val(u_det_all_trials[i]) if i < len(u_det_all_trials) else '',
            fmt_val(hatuc_det_all_trials[i]) if i < len(hatuc_det_all_trials) else '',
            fmt_val(gamma_at_detection_all_trials[i]) if i < len(gamma_at_detection_all_trials) else '',
            fmt_val(best_corr_at_detection_all_trials[i]) if i < len(best_corr_at_detection_all_trials) else ''
        ]
        writer.writerow(row)

print(f"Wrote detection summary to {output_file}")

# --- Save raw data from the last trial for future plotting ---
last_trial_data = pd.DataFrame({
    'u_values': u_values,
    'var_values': var_values
})

# Apply specific rounding: 5 digits for c, 10 digits for var
last_trial_data = last_trial_data.round({'u_values': 5, 'var_values': 10})

last_trial_data.to_csv('last_trial_raw_data.csv', index=False)
print(f"Raw data from the last trial saved to last_trial_raw_data.csv")

fig, ax = plt.subplots(figsize=(7, 5))
fig.subplots_adjust(left=0.12, right=0.98, top=0.9, bottom=0.1)

# Data points, black circles, no connecting lines
ax.plot(
    u_values, var_values,
    'o',  # circles
    color='black',  # black
    linestyle='None',  # no connecting lines
    label='Data'
)

# Power-law fit (entire data), solid black line
a_fit = a_values[-1]
b_fit = b_values[-1]
hatuc_fit = hatuc_values[-1]
gamma_fit = gamma_values[-1]
powerlaw_fit = a_fit / np.power(hatuc_fit - u_values, gamma_fit) + b_fit
ax.plot(
    u_values, powerlaw_fit,
    color='black',  # black
    linestyle='-',  # solid line
    label='Power-law fit (entire data)'
)

if detected:
    det_array_idx = detected_idx - i0
    a = a_values[det_array_idx]
    b = b_values[det_array_idx]
    hatuc = hatuc_values[det_array_idx]
    gamma = gamma_values[det_array_idx]
    window_u_values = u_values[:detected_idx]
    powerlaw_fit_det = a / np.power(hatuc - window_u_values, gamma) + b
    ax.plot(
        window_u_values, powerlaw_fit_det,
        color='blue',
        linestyle='--',  # dashed
        label='Power-law fit (at detection)'
    )

    # Linear fit (at detection) -- red dashed line
    a, b = popt_lin_values[det_array_idx]
    window_u_values = np.array(window_u_values)
    lin_fit_det = a * window_u_values + b
    ax.plot(
        window_u_values, lin_fit_det,
        color='red',
        linestyle='--',
        label='Linear fit (at detection)'
    )

# Axis labels
ax.set_xlabel(r'$u$', fontsize=18)
ax.set_ylabel('Sample variance', fontsize=18)

# y minimum
ax.set_ylim(bottom=0)

if dynamics==1: # double-well. We only care the double-well system because Figures 2(a) and 2(b) are generated for the double-well system.
    ax.set_ylim(top=0.0015)
    formatter = ticker.ScalarFormatter(useMathText=True)
    formatter.set_scientific(True)
    formatter.set_powerlimits((-3, -3)) # Forces 10^-3 specifically
    ax.yaxis.set_major_formatter(formatter)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(0.0005))
    ax.yaxis.get_offset_text().set_fontsize(14)

# Grid + legend
ax.grid(True, which='both', linestyle=':', alpha=0.5)
ax.legend(fontsize=12)

# Add label '(a)' OUTSIDE upper left of plot box:
ax.annotate(
    '(a)',
    xy=(-0.08, 1.09),  # position outside the axes: tweak as needed
    xycoords='axes fraction',
    fontsize=20,
#    fontweight='bold',
    ha='left', va='top'
)

fig.savefig('panel_a.pdf')
plt.close(fig)

fig, ax = plt.subplots(figsize=(7, 5))  # shorter panel
fig.subplots_adjust(left=0.12, right=0.98, top=0.9, bottom=0.1)

# ΔAIC as a function of u (assuming delta_aiu_values = ΔAIC for u_values)
ax.plot(
    u_values[i0-1:], delta_AICc_values,
    color='black',
    linestyle='-',  # solid
    label=r'$\Delta \mathrm{AIC}$'
)

# Gray horizontal reference line at ΔAIC = 0
ax.axhline(-10, color='gray', linewidth=1, linestyle='-')

ax.set_xlim(np.min(u_values), np.max(u_values))

ax.set_xlabel(r'$u$', fontsize=18)
ax.set_ylabel(r'$\Delta \mathrm{AIC}$', fontsize=18)

ax.grid(True, which='both', linestyle=':', alpha=0.4)

# Panel label 'b' outside plot, upper left
ax.annotate(
    '(b)',
    xy=(-0.08, 1.09),
    xycoords='axes fraction',
    fontsize=20,
#    fontweight='bold',
    ha='left', va='top'
)

fig.savefig('panel_b.pdf')
plt.close(fig)