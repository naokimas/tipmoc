"""
Differently from test_tipmoc_100_1.py, this code does not run simulations but uses the saved simulation data, allowing fine tuning of the appearance of figures.
This code was used for producing final Figures 2(a) and 2(b).

Input:

    last_trial_raw_data_dw.csv --> This file is renamed from last_trial_raw_data.csv generated by tipmoc_100_1.py

Output:

    panel_a.pdf --> Figure 2(a)
    panel_b.pdf --> Figure 2(b)
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.stats import kendalltau

import delta_aicc as dAICc

# -----------------------------
# Configuration (must match run)
# -----------------------------

i0 = 8
threshold_AICc = -10

# -----------------------------
# Load last-trial raw data
# -----------------------------
df = pd.read_csv('last_trial_raw_data_dw.csv')
u_values = df['u_values'].values
var_values = df['var_values'].values
num_u = len(u_values)

# -----------------------------
# Recompute windowed AIC scan
# -----------------------------
delta_AICc_values = []
a_values = []
b_values = []
hatuc_values = []
gamma_values = []
best_corr_values = []
popt_lin_values = []

for i in range(i0, num_u + 1):
    window_u = u_values[:i]
    window_var = var_values[:i]

    delta_AICc, popt_lin, a, b, hatuc, gamma, best_corr = \
        dAICc.delta_AICc(window_u, window_var)

    delta_AICc_values.append(delta_AICc)
    a_values.append(a)
    b_values.append(b)
    hatuc_values.append(hatuc)
    gamma_values.append(gamma)
    best_corr_values.append(best_corr)
    popt_lin_values.append(popt_lin)

delta_AICc_values = np.array(delta_AICc_values)
a_values = np.array(a_values, dtype=float)
b_values = np.array(b_values, dtype=float)
hatuc_values = np.array(hatuc_values, dtype=float)
gamma_values = np.array(gamma_values, dtype=float)
popt_lin_values = np.array(popt_lin_values, dtype=float)

# -----------------------------
# Detection logic (unchanged)
# -----------------------------
detected = False
detected_idx = None

for j in range(len(delta_AICc_values) - 2):
    if np.all(~np.isnan(delta_AICc_values[j:j+3])):
        if np.all(delta_AICc_values[j:j+3] <= threshold_AICc):
            detected = True
            detected_idx = i0 + j + 2
            break

# -----------------------------
# Figure 2(a): \hat{V} vs u
# -----------------------------
fig, ax = plt.subplots(figsize=(7, 5))
fig.subplots_adjust(left=0.12, right=0.98, top=0.9, bottom=0.1)

# Data points
ax.plot(
    u_values, var_values,
    'o',
    color='black',
    linestyle='None',
    label='Data'
)

ax.set_ylim(top=0.0016)
formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_scientific(True)
formatter.set_powerlimits((-3, -3))
ax.yaxis.set_major_formatter(formatter)
ax.yaxis.set_major_locator(ticker.MultipleLocator(0.0005))
ax.yaxis.get_offset_text().set_fontsize(16)
ax.tick_params(axis='x', labelsize=16)
ax.tick_params(axis='y', labelsize=16)

# ----- Global power-law fit (entire data) -----
a_fit = a_values[-1]
b_fit = b_values[-1]
hatuc_fit = hatuc_values[-1]
gamma_fit = gamma_values[-1]

powerlaw_fit = a_fit / np.power(hatuc_fit - u_values, gamma_fit) + b_fit
ax.plot(
    u_values, powerlaw_fit,
    color='black',
    linestyle='-',
    label='Power-law fit (entire data)'
)

# ----- Detection fits -----
if detected:
    det_array_idx = detected_idx - i0

    a_det = a_values[det_array_idx]
    b_det = b_values[det_array_idx]
    hatuc_det = hatuc_values[det_array_idx]
    gamma_det = gamma_values[det_array_idx]

    window_u = u_values[:detected_idx]

    # Power-law at detection
    powerlaw_fit_det = a_det / np.power(hatuc_det - window_u, gamma_det) + b_det
    ax.plot(
        window_u, powerlaw_fit_det,
        color='blue',
        linestyle='--',
        label='Power-law fit (at detection)'
    )

    # Linear fit at detection
    a_lin, b_lin = popt_lin_values[det_array_idx]
    lin_fit_det = a_lin * window_u + b_lin
    ax.plot(
        window_u, lin_fit_det,
        color='red',
        linestyle='--',
        label='Linear fit (at detection)'
    )

u_min = 0.0
u_crit_theoretical = 3.079
u_max_base = u_crit_theoretical
x_range = u_max_base - u_min
ax.set_xlim(
    left=u_min - x_range * 0.0125,
    right=u_max_base + x_range * 0.02
)


# Axis labels
ax.set_xlabel(r'$u$', fontsize=18, labelpad=-3)
ax.set_ylabel(r'$\hat{V}$', fontsize=18, labelpad=-3)
ax.set_ylim(bottom=0)

# ----- Dynamics-specific formatting -----
ax.set_ylim(top=0.0016)
formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_scientific(True)
formatter.set_powerlimits((-3, -3))
ax.yaxis.set_major_formatter(formatter)
ax.yaxis.set_major_locator(ticker.MultipleLocator(0.0005))
ax.yaxis.get_offset_text().set_fontsize(14)

# Grid + legend
ax.grid(True, which='both', linestyle=':', alpha=0.5)
ax.legend(fontsize=16)

# Panel label
ax.annotate(
    '(a)',
    xy=(-0.08, 1.09),
    xycoords='axes fraction',
    fontsize=20,
    ha='left', va='top'
)

fig.savefig('panel_a.pdf')
plt.close(fig)

# -----------------------------
# Figure 2(b): Î”AIC vs u
# -----------------------------
fig, ax = plt.subplots(figsize=(7, 5))
fig.subplots_adjust(left=0.12, right=0.98, top=0.9, bottom=0.1)

ax.plot(
    u_values[i0-1:], delta_AICc_values,
    color='black',
    linestyle='-',
    label=r'$\Delta \mathrm{AIC}$'
)

ax.axhline(threshold_AICc, color='gray', linewidth=1)

ax.set_xlim(np.min(u_values), np.max(u_values))
ax.set_xlabel(r'$u$', fontsize=18, labelpad=-3)
ax.set_ylabel(r'$\Delta \mathrm{AIC}$', fontsize=18, labelpad=-10)
ax.set_ylim(bottom=-125)
ax.set_ylim(top=25)
ax.tick_params(axis='x', labelsize=16)
ax.tick_params(axis='y', labelsize=16)
ax.yaxis.set_major_locator(ticker.MultipleLocator(25))

ax.grid(True, which='both', linestyle=':', alpha=0.4)

ax.annotate(
    '(b)',
    xy=(-0.08, 1.09),
    xycoords='axes fraction',
    fontsize=20,
    ha='left', va='top'
)

fig.savefig('panel_b.pdf')
plt.close(fig)

print("Success: panel_a.pdf and panel_b.pdf reproduced from last_trial_raw_data.csv")
